import re
from _typeshed import Incomplete
from collections import OrderedDict
from collections.abc import Callable, Generator
from logging import Logger
from types import TracebackType
from typing import Any

__pkgname__: str
ITEMREX: re.Pattern[str]
SPECREX: re.Pattern[str]
DEVNULL: str
WEEK_ENUM: list[str]
MONTH_ENUM: list[str | None]
SPECIALS: dict[str, str]
SPECIAL_IGNORE: list[str]
S_INFO: list[dict[str, Any]]
PY3: bool
WINOS: bool
POSIX: bool
SYSTEMV: bool
ZERO_PAD: bool
LOG: Logger
CRON_COMMAND: str
SHELL: str
current_user: Callable[[], str | None]
unicode = str
basestring = str

def open_pipe(cmd: str, *args: str, **flags) -> subprocess.Popen: ...

class CronTab:
    lines: Incomplete
    crons: Incomplete
    filen: Incomplete
    cron_command: Incomplete
    env: Incomplete
    root: bool
    intab: Incomplete
    def __init__(
        self, user: str | None = ..., tab: Incomplete | None = ..., tabfile: Incomplete | None = ..., log: Incomplete | None = ...
    ) -> None: ...
    def __enter__(self: Self) -> Self: ...
    def __exit__(
        self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None
    ) -> None: ...
    @property
    def log(self) -> Incomplete: ...
    @property
    def user(self) -> str | None: ...
    @property
    def user_opt(self) -> Incomplete: ...
    def read(self, filename: Incomplete | None = ...) -> None: ...
    def append(self, item: Incomplete, line: str = ..., read: bool = ...) -> None: ...
    def write(self, filename: Incomplete | None = ..., user: Incomplete | None = ..., errors: bool = ...) -> None: ...
    def write_to_user(self, user: bool = ...) -> Incomplete: ...
    def run_pending(self, **kwargs) -> Generator[Incomplete, None, None]: ...
    def run_scheduler(self, timeout: int = ..., **kwargs) -> Generator[Incomplete, None, None]: ...
    def render(self, errors: bool = ..., specials: bool = ...) -> Incomplete: ...
    def new(
        self, command: str = ..., comment: str = ..., user: Incomplete | None = ..., pre_comment: bool = ...
    ) -> CronItem: ...
    def find_command(self, command) -> Generator[Incomplete, None, None]: ...
    def find_comment(self, comment) -> Generator[Incomplete, None, None]: ...
    def find_time(self, *args) -> Generator[Incomplete, None, None]: ...
    @property
    def commands(self) -> Generator[Incomplete, None, None]: ...
    @property
    def comments(self) -> Generator[Incomplete, None, None]: ...
    def remove_all(self, *args, **kwargs): ...
    def remove(self, *items): ...
    def __iter__(self) -> Incomplete: ...
    def __getitem__(self, i: Incomplete) -> Incomplete: ...
    def __unicode__(self) -> Incomplete: ...
    def __len__(self) -> int: ...

class CronItem:
    cron: Incomplete
    user: Incomplete
    valid: bool
    enabled: bool
    special: bool
    comment: Incomplete
    command: Incomplete
    last_run: Incomplete
    env: Incomplete
    pre_comment: bool
    marker: Incomplete
    stdin: Incomplete
    slices: Incomplete
    def __init__(
        self, command: str = ..., comment: str = ..., user: Incomplete | None = ..., pre_comment: bool = ...
    ) -> None: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    @classmethod
    def from_line(cls: type[Self], line: str, user: Incomplete | None = ..., cron: Incomplete | None = ...) -> Self: ...
    def delete(self) -> None: ...
    def set_command(self, cmd: str, parse_stdin: bool = ...) -> None: ...
    def set_comment(self, cmt: str, pre_comment: bool = ...) -> None: ...
    def parse(self, line: Incomplete) -> None: ...
    def enable(self, enabled: bool = ...) -> bool: ...
    def is_enabled(self) -> bool: ...
    def is_valid(self) -> bool: ...
    def render(self, specials: bool = ...) -> str: ...
    def every_reboot(self) -> Incomplete: ...
    def every(self, unit: int = ...) -> Incomplete: ...
    def setall(self, *args: Any) -> Incomplete: ...
    def clear(self) -> Incomplete: ...
    def frequency(self, year: Incomplete | None = ...) -> Incomplete: ...
    def frequency_per_year(self, year: Incomplete | None = ...) -> Incomplete: ...
    def frequency_per_day(self) -> Incomplete: ...
    def frequency_per_hour(self) -> Incomplete: ...
    def run_pending(self, now: Incomplete | None = ...) -> Incomplete: ...
    def run(self) -> Incomplete: ...
    def schedule(self, date_from: Incomplete | None = ...) -> Incomplete: ...
    def description(self, **kw: Any) -> Incomplete: ...
    @property
    def log(self) -> Incomplete: ...
    @property
    def minute(self) -> Incomplete: ...
    @property
    def minutes(self) -> Incomplete: ...
    @property
    def hour(self) -> Incomplete: ...
    @property
    def hours(self) -> Incomplete: ...
    @property
    def day(self) -> Incomplete: ...
    @property
    def dom(self) -> Incomplete: ...
    @property
    def month(self) -> Incomplete: ...
    @property
    def months(self) -> Incomplete: ...
    @property
    def dow(self) -> Incomplete: ...
    def __len__(self) -> Incomplete: ...
    def __getitem__(self, key: str) -> Incomplete: ...
    def __lt__(self, value: Incomplete) -> Incomplete: ...
    def __gt__(self, value: Incomplete) -> Incomplete: ...
    def __unicode__(self) -> Incomplete: ...

class Every:
    slices: Incomplete
    unit: Incomplete
    def __init__(self, item: Incomplete, units: Incomplete) -> None: ...
    def set_attr(self, target: int) -> Callable[[], None]: ...
    def year(self) -> None: ...

class CronSlices(list[CronSlice]):
    special: Incomplete
    def __init__(self, *args: Any) -> None: ...
    def is_self_valid(self, *args: Any) -> Incomplete: ...
    @classmethod
    def is_valid(cls, *args: Any) -> Incomplete: ...
    def setall(self, *slices: Incomplete) -> None: ...
    def clean_render(self) -> str: ...
    def render(self, specials: bool = ...) -> str: ...
    def clear(self) -> None: ...
    def frequency(self, year: Incomplete | None = ...) -> Incomplete: ...
    def frequency_per_year(self, year: Incomplete | None = ...) -> Incomplete: ...
    def frequency_per_day(self) -> Incomplete: ...
    def frequency_per_hour(self) -> Incomplete: ...
    def __eq__(self, arg: object) -> bool: ...

class SundayError(KeyError): ...

class Also:
    obj: Incomplete
    def __init__(self, obj: Incomplete) -> None: ...
    def every(self, *a: Incomplete) -> Incomplete: ...
    def on(self, *a: Incomplete) -> Incomplete: ...
    def during(self, *a: Incomplete) -> Incomplete: ...

class CronSlice:
    min: Incomplete
    max: Incomplete
    name: Incomplete
    enum: Incomplete
    parts: Incomplete
    def __init__(self, info: Incomplete, value: Incomplete | None = ...) -> None: ...
    def __hash__(self) -> Incomplete: ...
    def parse(self, value: Incomplete) -> None: ...
    def render(self, resolve: bool = ..., specials: bool = ...) -> Incomplete: ...
    def __eq__(self, arg: object) -> bool: ...
    def __unicode__(self) -> Incomplete: ...
    def every(self, n_value: Incomplete, also: bool = ...) -> Incomplete: ...
    def on(self, *n_value: Incomplete, **opts: Incomplete) -> Incomplete: ...
    def during(self, vfrom: Incomplete, vto: Incomplete, also: bool = ...) -> Incomplete: ...
    @property
    def also(self) -> Incomplete: ...
    def clear(self) -> None: ...
    def get_range(self, *vrange: Incomplete) -> Incomplete: ...
    def __iter__(self) -> Incomplete: ...
    def __len__(self) -> Incomplete: ...
    def parse_value(self, val: Incomplete, sunday: Incomplete | None = ...) -> Incomplete: ...

def get_cronvalue(value: Incomplete, enums: Incomplete) -> Incomplete: ...

class CronValue:
    text: Incomplete
    value: Incomplete
    def __init__(self, value: Incomplete, enums: Incomplete) -> None: ...
    def __lt__(self, value: Incomplete) -> Incomplete: ...
    def __int__(self) -> int: ...

class CronRange:
    dangling: Incomplete
    slice: Incomplete
    cron: Incomplete
    seq: int
    def __init__(self, vslice: Incomplete, *vrange: Incomplete) -> None: ...
    vfrom: Incomplete
    vto: Incomplete
    def parse(self, value: Incomplete) -> None: ...
    def all(self) -> None: ...
    def render(self, resolve: bool = ...) -> Incomplete: ...
    def range(self) -> Incomplete: ...
    def every(self, value: Incomplete) -> None: ...
    def __lt__(self, value: Incomplete) -> Incomplete: ...
    def __gt__(self, value: Incomplete) -> Incomplete: ...
    def __int__(self) -> int: ...
    def __unicode__(self) -> Incomplete: ...

class OrderedVariableList(OrderedDict[Incomplete, Incomplete]):
    job: Incomplete
    def __init__(self, *args: Any, **kw: Any) -> None: ...
    @property
    def previous(self) -> Incomplete: ...
    def all(self) -> Incomplete: ...
    def __getitem__(self, key: Incomplete) -> Incomplete: ...
